'use strict';

var _chai = require('chai');

var _chai2 = _interopRequireDefault(_chai);

var _logLevel = require('./logLevel');

var _logLevel2 = _interopRequireDefault(_logLevel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var expect = _chai2.default.expect;

describe('logLevel', function () {

  it('should return "warn" when called with production and no overrides', _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
    var level, expected;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            level = (0, _logLevel2.default)('production');
            expected = 'warn';


            expect(level).to.equal(expected);

          case 3:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  })));

  it('should return "debug" when called with development and no overrides', _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
    var level, expected;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            level = (0, _logLevel2.default)('development');
            expected = 'debug';


            expect(level).to.equal(expected);

          case 3:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  })));

  it('should return "warn" when called with test and no overrides', _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
    var level, expected;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            level = (0, _logLevel2.default)('test');
            expected = 'warn';


            expect(level).to.equal(expected);

          case 3:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  })));

  it('should return "info" for anything else', _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
    var level, expected;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            level = (0, _logLevel2.default)('anything else');
            expected = 'info';


            expect(level).to.equal(expected);

          case 3:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, this);
  })));

  it('should return the default level when it is provided and an env-specific level is not', _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {
    var defaultLevel, level, expected;
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            defaultLevel = 'error';
            level = (0, _logLevel2.default)('anything else', { defaultLevel: defaultLevel });
            expected = defaultLevel;


            expect(level).to.equal(expected);

          case 4:
          case 'end':
            return _context5.stop();
        }
      }
    }, _callee5, this);
  })));

  it('should return the "warn" when production is used, even when defaultLevel is provided', _asyncToGenerator(regeneratorRuntime.mark(function _callee6() {
    var defaultLevel, level, expected;
    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            defaultLevel = 'error';
            level = (0, _logLevel2.default)('production', { defaultLevel: defaultLevel });
            expected = 'warn';


            expect(level).to.equal(expected);

          case 4:
          case 'end':
            return _context6.stop();
        }
      }
    }, _callee6, this);
  })));

  it('should add new levels when the levels option is passed', _asyncToGenerator(regeneratorRuntime.mark(function _callee7() {
    var levels, level, expected;
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            levels = {
              'anything else': 'error'
            };
            level = (0, _logLevel2.default)('anything else', { levels: levels });
            expected = 'error';


            expect(level).to.equal(expected);

          case 4:
          case 'end':
            return _context7.stop();
        }
      }
    }, _callee7, this);
  })));

  it('should not change the default level when providing new levels', _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {
    var levels, level, expected;
    return regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            levels = {
              'anything else': 'error'
            };
            level = (0, _logLevel2.default)('production', { levels: levels });
            expected = 'warn';


            expect(level).to.equal(expected);

          case 4:
          case 'end':
            return _context8.stop();
        }
      }
    }, _callee8, this);
  })));

  it('should override the default when a level with the same name is provided', _asyncToGenerator(regeneratorRuntime.mark(function _callee9() {
    var levels, level, expected;
    return regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            levels = {
              production: 'error'
            };
            level = (0, _logLevel2.default)('production', { levels: levels });
            expected = 'error';


            expect(level).to.equal(expected);

          case 4:
          case 'end':
            return _context9.stop();
        }
      }
    }, _callee9, this);
  })));
});
//# sourceMappingURL=logLevel.spec.js.map
